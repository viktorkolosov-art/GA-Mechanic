<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Механіка обнулення</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  background: #000 !important;
  color: #FFF !important;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 20px;
  margin: 0;
  overflow-y: auto;
  -webkit-text-size-adjust: 100%;
  background-color: #000 !important;
}

.card {
  width: 100%;
  max-width: 980px;
  padding: 0;
  background: transparent !important;
  border-radius: 0;
  box-shadow: none;
  flex-shrink: 0;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 15px;
  gap: 10px;
}

h1 {
  font-size: 22px;
  color: #FFF !important;
  letter-spacing: 0.01em;
  text-align: left;
  word-break: break-word;
  line-height: 1.4;
  white-space: pre-line;
  flex: 1;
}

.button-group {
  display: flex;
  gap: 10px;
  flex-shrink: 0;
}

button {
  background: #222;          /* ухо по умолчанию тёмное, "неактивное" */
  border: none;
  color: #FFF;
  padding: 0;
  border-radius: 5px;
  cursor: pointer;
  white-space: nowrap;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  position: relative;
}

button:active {
  background: #444;
}

button svg {
  width: 28px;
  height: 28px;
}

/* снежинка чуть светлее уха */
#freezeBtn {
  background: #333;
}

#freezeBtn:active {
  background: #555;
}

/* КАРТИНКА ПОД ЗАГОЛОВКОМ С БЕЛОЙ РАМКОЙ */
.image-strip {
  width: 100%;
  margin-bottom: 20px;
  display: block;
  border: 2px solid #FFF;
  padding: 2px;
  background: #FFF;
}

.image-strip img {
  width: 100%;
  height: auto;
  display: block;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: crisp-edges;
}

/* ТЕКСТ */
.content {
  background: transparent !important;
  padding: 0;
  border-radius: 0;
  line-height: 1.6;
  font-size: 18px;
  color: #FFF !important;
}

.content p {
  margin-bottom: 15px;
  color: #FFF !important;
}

.content p:last-child {
  margin-bottom: 0;
}

.word {
  display: inline;
  transition: opacity 300ms ease-in-out;
}

@media (max-width: 600px) {
  body {
    padding: 10px;
  }
  .header {
    flex-direction: row;
    align-items: flex-start;
  }
  h1 {
    font-size: 18px;
  }
  .content {
    font-size: 16px;
  }
}
</style>
</head>
<body>
<div class="card" role="main">
  <div class="header">
    <h1>Блок 1.
«Механіка обнулення», 2016,
проєкт «Глобальна адаптація», 200 × 210 см,
п'ять частин, 35 робіт (розмір кожної роботи: 35 = 40 × 30 см), акрил, антиживопис.</h1>
    <div class="button-group">
      <!-- ухо -->
      <button id="muteBtn" aria-label="Звук">
        <svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M 20 6 C 22 6 25 8 26 12 C 27 16 26 20 24 23 C 23 24 22 25 20 25" 
                stroke="#FFF" stroke-width="2.5" stroke-linecap="round" fill="none"/>
          <path d="M 20 10 C 21 10 22 11 22.5 13 C 23 15 22.5 17 21 18.5" 
                stroke="#FFF" stroke-width="2.5" stroke-linecap="round" fill="none"/>
          <path d="M 19 24 C 18 25 17 25.5 16 25" 
                stroke="#FFF" stroke-width="2.5" stroke-linecap="round" fill="none"/>
        </svg>
      </button>

      <!-- снежинка -->
      <button id="freezeBtn" aria-label="Заморозити">
        <svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
          <!-- Вертикальная линия -->
          <line x1="16" y1="4" x2="16" y2="28" stroke="#FFF" stroke-width="2" stroke-linecap="round"/>
          <!-- Горизонтальная линия -->
          <line x1="4" y1="16" x2="28" y2="16" stroke="#FFF" stroke-width="2" stroke-linecap="round"/>
          <!-- Диагональ 1 -->
          <line x1="7" y1="7" x2="25" y2="25" stroke="#FFF" stroke-width="2" stroke-linecap="round"/>
          <!-- Диагональ 2 -->
          <line x1="25" y1="7" x2="7" y2="25" stroke="#FFF" stroke-width="2" stroke-linecap="round"/>
          
          <!-- Ответвления на концах -->
          <!-- Верх -->
          <line x1="16" y1="4" x2="13" y2="7" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="16" y1="4" x2="19" y2="7" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Низ -->
          <line x1="16" y1="28" x2="13" y2="25" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="16" y1="28" x2="19" y2="25" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Лево -->
          <line x1="4" y1="16" x2="7" y2="13" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="4" y1="16" x2="7" y2="19" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Право -->
          <line x1="28" y1="16" x2="25" y2="13" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="28" y1="16" x2="25" y2="19" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Диагональ верх-лево -->
          <line x1="7" y1="7" x2="9" y2="5" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="7" y1="7" x2="5" y2="9" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Диагональ верх-право -->
          <line x1="25" y1="7" x2="23" y2="5" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="25" y1="7" x2="27" y2="9" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Диагональ низ-лево -->
          <line x1="7" y1="25" x2="5" y2="23" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="7" y1="25" x2="9" y2="27" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Диагональ низ-право -->
          <line x1="25" y1="25" x2="27" y2="23" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="25" y1="25" x2="23" y2="27" stroke="#FFF" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
      </button>
    </div>
  </div>

  <!-- КАРТИНКА ПОД ЗАГОЛОВКОМ -->
  <div class="image-strip">
    <img src="Fragment Mechanic.png" alt="Механіка обнулення">
  </div>

  <div class="content" id="textContent">
    <p>Ця картина — про те, як ми намагаємося зберегти себе в світі, що постійно змінюється. Вона про те, як ми шукаємо баланс між тим, що було, і тим, що буде. Про те, як ми намагаємося зберегти свою ідентичність у світі, що постійно змінюється.</p>

    <p>Механіка обнулення — це процес, коли ми скидаємо все зайве, щоб знайти себе справжніх. Це про те, як ми позбуваємося нашарувань, які накопичилися за роки, щоб знайти свою суть.</p>

    <p>У цій картині закодовано ідею циклічності: все повертається, все починається знову. Але кожен новий цикл — це не просто повторення, а новий виток спіралі, де ми стаємо трохи іншими, трохи мудрішими.</p>

    <p>Фігури на полотні нагадують про те, що ми всі — частина великого механізму, де кожен рух має значення. Де кожна дія породжує наслідки. Де все взаємопов'язане.</p>

    <p>Це картина про пошук себе в хаосі сучасного світу. Про те, як важливо іноді зупинитися, обнулитися і почати знову — вже з новим розумінням, з новою перспективою.</p>
  </div>
</div>

<script>
let audioCtx = null;
let masterGain = null;
let waveSound = { running: false, mute: false, timeout: null };
let textFrozen = false;
let shuffleTimeout = null;

// сохраняем исходный текст один раз — к нему будем возвращаться по "снежинке"
const ORIGINAL_HTML = document.getElementById('textContent').innerHTML;

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = waveSound.mute ? 0 : 1.0;
    masterGain.connect(audioCtx.destination);

    waveSound.running = true;
    scheduleWave();
  } catch (e) {
    console.warn('AudioContext not available:', e);
    waveSound.running = false;
    document.getElementById('muteBtn').style.display = 'none';
  }
}

// --- ЗВУК ВОЛН ---
function makeCrash(startTime, intensity = 1.0) {
  if (!audioCtx || !waveSound.running) return;
  
  const crashDuration = 3.6;
  const crashNoise = audioCtx.createBufferSource();
  const crashBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * crashDuration, audioCtx.sampleRate);
  const crashData = crashBuffer.getChannelData(0);
  
  for (let i = 0; i < crashData.length; i++) {
    crashData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.9));
  }
  
  crashNoise.buffer = crashBuffer;
  
  const crashFilter = audioCtx.createBiquadFilter();
  crashFilter.type = 'lowpass';
  crashFilter.frequency.value = 400;
  crashFilter.Q.value = 0.7;
  
  const crashDelay = audioCtx.createDelay();
  crashDelay.delayTime.value = 0.15;
  const crashEchoGain = audioCtx.createGain();
  crashEchoGain.gain.value = 0.4;
  
  const crashGain = audioCtx.createGain();
  crashGain.gain.setValueAtTime(0.0001, startTime);
  crashGain.gain.exponentialRampToValueAtTime(1.2 * intensity, startTime + 0.3);
  crashGain.gain.linearRampToValueAtTime(0.9 * intensity, startTime + crashDuration * 0.5);
  crashGain.gain.exponentialRampToValueAtTime(0.4 * intensity, startTime + crashDuration);
  
  crashNoise.connect(crashFilter);
  crashFilter.connect(crashGain);
  crashGain.connect(masterGain);
  
  crashGain.connect(crashDelay);
  crashDelay.connect(crashEchoGain);
  crashEchoGain.connect(masterGain);
  
  crashNoise.start(startTime);
  crashNoise.stop(startTime + crashDuration);
  
  return crashDuration;
}

function makeRetreat(startTime) {
  if (!audioCtx || !waveSound.running) return;
  
  const retreatDuration = 6.5;
  
  const retreatNoise = audioCtx.createBufferSource();
  const retreatBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * retreatDuration, audioCtx.sampleRate);
  const retreatData = retreatBuffer.getChannelData(0);
  
  for (let i = 0; i < retreatData.length; i++) {
    retreatData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 1.8));
  }
  
  retreatNoise.buffer = retreatBuffer;
  
  const retreatFilter = audioCtx.createBiquadFilter();
  retreatFilter.type = 'highpass';
  retreatFilter.frequency.value = 300;
  retreatFilter.Q.value = 0.4;
  
  const retreatGain = audioCtx.createGain();
  retreatGain.gain.setValueAtTime(0.0001, startTime);
  retreatGain.gain.exponentialRampToValueAtTime(0.08, startTime + 1.2);
  retreatGain.gain.linearRampToValueAtTime(0.06, startTime + retreatDuration * 0.5);
  retreatGain.gain.exponentialRampToValueAtTime(0.0001, startTime + retreatDuration);
  
  retreatNoise.connect(retreatFilter);
  retreatFilter.connect(retreatGain);
  retreatGain.connect(masterGain);
  
  retreatNoise.start(startTime);
  retreatNoise.stop(startTime + retreatDuration);
  
  return retreatDuration;
}

function makeWaveSound() {
  if (!audioCtx || !waveSound.running) return;

  const now = audioCtx.currentTime;
  const isDouble = Math.random() < 0.25;
  
  if (isDouble) {
    const firstCrashDuration = makeCrash(now, 1.0);
    const secondCrashStart = now + firstCrashDuration - 1.5;
    const secondCrashDuration = makeCrash(secondCrashStart, 0.95);
    const retreatStart = secondCrashStart + secondCrashDuration - 1.0;
    makeRetreat(retreatStart);
  } else {
    const crashDuration = makeCrash(now, 1.0);
    const retreatStart = now + crashDuration - 1.0;
    makeRetreat(retreatStart);
  }
}

function scheduleWave() {
  if (!waveSound.running) return;
  makeWaveSound();
  const nextDelay = 7000 + Math.random() * 2000;
  waveSound.timeout = setTimeout(scheduleWave, nextDelay);
}

// --- ТЕКСТОВАЯ АНИМАЦИЯ ---
function wrapWords() {
  const content = document.getElementById('textContent');
  const paragraphs = content.querySelectorAll('p');
  
  paragraphs.forEach(p => {
    const text = p.textContent;
    const words = text.split(/(\s+)/);
    p.innerHTML = words.map(word => 
      word.trim() ? `<span class="word">${word}</span>` : word
    ).join('');
  });
}

function shuffleOnce() {
  if (textFrozen) return;
  
  const spans = document.querySelectorAll('.word');
  if (spans.length === 0) return;
  
  const allWords = Array.from(spans).map(s => s.textContent);
  const shuffled = allWords.slice().sort(() => Math.random() - 0.5);
  
  spans.forEach((span, i) => {
    span.textContent = shuffled[i];
  });
  
  const baseDelay = 3300;
  const variance = 900;
  const nextDelay = baseDelay + Math.random() * variance;
  
  shuffleTimeout = setTimeout(shuffleOnce, nextDelay);
}

// --- Кнопка уха (звук) ---
const muteBtn = document.getElementById('muteBtn');

muteBtn.onclick = () => {
  if (!audioCtx) {
    initAudio();
    if (!audioCtx) return;
  }
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }

  waveSound.mute = !waveSound.mute;
  
  const now = audioCtx.currentTime;
  masterGain.gain.cancelScheduledValues(now);
  masterGain.gain.setValueAtTime(masterGain.gain.value, now);
  masterGain.gain.exponentialRampToValueAtTime(waveSound.mute ? 0.0001 : 1.0, now + 0.3);
  
  // тёмная кнопка = звук выключен, светлее = включён
  muteBtn.style.background = waveSound.mute ? '#222' : '#555';
};

// --- Кнопка снежинки (временная "заморозка") ---
const freezeBtn = document.getElementById('freezeBtn');

freezeBtn.onclick = () => {
  if (textFrozen) return;         // пока уже заморожено — игнорируем повторные клики
  
  textFrozen = true;
  freezeBtn.style.background = '#777';  // подсветить как активную

  // останавливаем текущее перемешивание
  if (shuffleTimeout) {
    clearTimeout(shuffleTimeout);
    shuffleTimeout = null;
  }

  const content = document.getElementById('textContent');
  // вернуть исходный, "правильный" текст (без спанов)
  content.innerHTML = ORIGINAL_HTML;

  // через 2–3 секунды снова включить анимацию
  const delay = 2000 + Math.random() * 1000; // 2000–3000 мс
  setTimeout(() => {
    textFrozen = false;
    freezeBtn.style.background = '#333'; // вернуть обычный цвет

    // снова завернуть слова в span'ы и запустить цикл перемешивания
    wrapWords();
    shuffleOnce();
  }, delay);
};

// Инициализация
wrapWords();
shuffleOnce();
</script>
</body>
</html>